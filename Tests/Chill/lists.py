# Tests/test_question_bank_compare.py
import pytest
import time
import json
from datetime import datetime, timezone, timedelta
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from Pages.login_page import LoginPage

# --------------------------
# GHI CH√ö CHUNG (important)
# - Y√™u c·∫ßu: trong conftest.py fixture `driver` ph·∫£i b·∫≠t performance logging:
#     options.set_capability("goog:loggingPrefs", {"performance": "ALL"})
#   v√† driver ph·∫£i ƒë∆∞·ª£c t·∫°o b·∫±ng: webdriver.Chrome(service=service, options=options)
# - Test n√†y l·∫•y response JSON t·ª´ Chrome DevTools log (performance),
#   kh√¥ng g·ªçi API tr·ª±c ti·∫øp. V√¨ v·∫≠y ph·∫£i ƒë·∫£m b·∫£o request / response ƒë√£ di·ªÖn ra tr∆∞·ªõc khi l·∫•y log.
# - UI table columns (theo y√™u c·∫ßu):
#     0: M√£ ƒë·ªãnh d·∫°ng
#     1: Ch·ªß ƒë·ªÅ
#     2: C√¢u h·ªèi
#     3: ƒê·ªô kh√≥
#     4: Ng√†y t·∫°o (UI format: dd/MM/YYYY HH:MM, timezone VN = UTC+7)
#     5: ƒêi·ªÉm
#     6: H√†nh ƒë·ªông (b·ªè qua so s√°nh)
# - API tr·∫£ `created_at` l√† ISO UTC nh∆∞: 2025-09-26T07:04:11.000000Z
#   c·∫ßn convert sang "26/09/2025 14:04" ƒë·ªÉ so s√°nh v·ªõi UI.
# --------------------------


def go_to_question_bank(driver):
    """M·ªü menu Ng√¢n h√†ng c√¢u h·ªèi v√† ch·ªù trang load xong.
       (Gi·ªØ nguy√™n nh∆∞ UI th·ª±c t·∫ø c·ªßa b·∫°n)."""
    wait = WebDriverWait(driver, 20)
    # XPATH menu c√≥ th·ªÉ kh√°c ‚Äî ch·ªânh l·∫°i n·∫øu project b·∫°n kh√°c selector
    menu = wait.until(EC.element_to_be_clickable(
        (By.XPATH, "//span[contains(text(),'Ng√¢n h√†ng c√¢u h·ªèi')]")
    ))
    # scroll + click b·∫±ng JS ƒë·ªÉ tr√°nh element b·ªã che
    driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", menu)
    driver.execute_script("arguments[0].click();", menu)
    # ch·ªù URL ch√≠nh x√°c (ho·∫∑c d√πng url_contains n·∫øu c√≥ params)
    wait.until(EC.url_to_be("https://school-beta.edulive.net/giao-vien/ngan-hang-cau-hoi"))
    print("‚úÖ V√†o trang Ng√¢n h√†ng c√¢u h·ªèi")


def get_api_quizzes_from_performance(driver, api_path="/api/apps/quizzes"):
    """
    L·∫•y response JSON c·ªßa API quizzes t·ª´ performance logs.
    Tr·∫£ v·ªÅ list c√°c item (data.data).
    Ghi ch√∫:
      - V√¨ Chrome c√≥ th·ªÉ xo√° resource nhanh, n√™n g·ªçi h√†m n√†y ngay sau khi trang load xong.
      - H√†m s·∫Ω t√¨m event Network.responseReceived c√≥ url ch·ª©a api_path,
        l·∫•y requestId v√† g·ªçi CDP Network.getResponseBody ƒë·ªÉ l·∫•y body.
    """
    try:
        logs = driver.get_log("performance")
    except Exception as e:
        print("‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c performance logs:", e)
        return []

    for entry in logs:
        try:
            msg = json.loads(entry["message"])["message"]
            # quan t√¢m event responseReceived ch·ª©a URL + requestId
            if msg.get("method") == "Network.responseReceived":
                resp = msg.get("params", {}).get("response", {})
                url = resp.get("url", "")
                if api_path in url:
                    request_id = msg["params"]["requestId"]
                    # L·∫•y response body qua CDP
                    try:
                        resp_body = driver.execute_cdp_cmd("Network.getResponseBody", {"requestId": request_id})
                    except Exception as e:
                        # Th∆∞·ªùng g·∫∑p l·ªói "No resource with given identifier found" n·∫øu request expired -> b·ªè qua
                        print("‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c response body (resource expired):", e)
                        continue

                    # resp_body c√≥ keys: 'body' (str) v√† 'base64Encoded' (bool)
                    body_text = resp_body.get("body", "")
                    try:
                        data = json.loads(body_text)
                        # theo c·∫•u tr√∫c sample: { result: true, data: { current_page:..., data: [ ... ] }, ... }
                        # ki·ªÉm tra t·ªìn t·∫°i path data.data
                        quizzes = data.get("data", {}).get("data", [])
                        print(f"üìå L·∫•y ƒë∆∞·ª£c API quizzes t·ª´: {url} (count={len(quizzes)})")
                        return quizzes
                    except Exception as e:
                        print("‚ö†Ô∏è JSON parse error:", e)
                        continue
        except Exception:
            # skip c√°c log kh√¥ng parse ƒë∆∞·ª£c
            continue

    print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y response quizzes trong performance logs")
    return []


def get_question_table_ui(driver):
    """
    ƒê·ªçc b·∫£ng UI (tbody rows) v√† tr·∫£ v·ªÅ list of lists:
    m·ªói row l√† list c√°c cell text (ƒë√£ strip).
    B·ªè qua rows r·ªóng/rows expand n·∫øu c·∫ßn.
    """
    # ch·ªçn tr c√≥ td (b·ªè c√°c tr r·ªóng / spacer)
    rows = driver.find_elements(By.XPATH, "//table/tbody/tr[td]")
    ui_data = []
    for row in rows:
        cols = [c.text.strip() for c in row.find_elements(By.TAG_NAME, "td")]
        # n·∫øu UI r√∫t g·ªçn c√¢u h·ªèi s·∫Ω c√≥ '...' ‚Äî gi·ªØ nguy√™n ƒë·ªÉ so s√°nh theo lu·∫≠t b√™n d∆∞·ªõi
        if cols:
            ui_data.append(cols)
    print(f"üìã L·∫•y ƒë∆∞·ª£c {len(ui_data)} rows t·ª´ UI")
    return ui_data


def format_created_at(api_time_str):
    """
    Convert API ISO UTC (e.g. 2025-09-26T07:04:11.000000Z)
    -> UI format dd/MM/YYYY HH:MM in Vietnam timezone (UTC+7), no seconds.
    Tr·∫£ v·ªÅ chu·ªói str ho·∫∑c "" n·∫øu parse l·ªói.
    """
    if not api_time_str:
        return ""
    try:
        # parse ISO with microseconds and trailing Z
        dt_utc = datetime.strptime(api_time_str, "%Y-%m-%dT%H:%M:%S.%fZ")
    except ValueError:
        # c√≥ th·ªÉ API tr·∫£ kh√°c d·∫°ng, th·ª≠ parse ng·∫Øn h∆°n (without microseconds)
        try:
            dt_utc = datetime.strptime(api_time_str, "%Y-%m-%dT%H:%M:%SZ")
        except Exception:
            return ""
    # attach tz and convert to UTC+7
    dt_utc = dt_utc.replace(tzinfo=timezone.utc)
    dt_vn = dt_utc.astimezone(timezone(timedelta(hours=7)))
    return dt_vn.strftime("%d/%m/%Y %H:%M")  # dd/MM/YYYY HH:MM


def map_api_item_to_ui_row(api_item, level_map=None):
    """
    Map 1 API item -> expected UI row (list of 7 values) to compare.
    level_map: optional dict to map numeric level -> Vietnamese text
    Returns list: [id, category_display, question, level_text, created_at_formatted, point, ""]
    - category_display: by default use quiz_category_id (string). If you want name, need extra mapping.
    """
    if level_map is None:
        level_map = {1: "M·ª©c 1", 2: "M·ª©c 2", 3: "M·ª©c 3"}  # adjust to your UI naming (your UI used "M·ª©c 1" earlier)
        # NOTE: you told earlier UI used "M·ª©c 1" etc. adjust if UI uses "D·ªÖ/Trung b√¨nh/Kh√≥"

    # category: API provides quiz_category_id (numeric). If UI shows name, you must map ids->names before compare.
    category_display = str(api_item.get("quiz_category_id", ""))

    return [
        str(api_item.get("unicode", "")),                     # M√£ ƒë·ªãnh d·∫°ng
        api_item.get("category_name", ""),# Ch·ªß ƒë·ªÅ (ID ‚Üí c√≥ th·ªÉ map sang t√™n n·∫øu c·∫ßn)
        api_item.get("question", ""),                    # C√¢u h·ªèi (full text from API)
        level_map.get(api_item.get("level", ""), ""),    # ƒê·ªô kh√≥ mapped (v√≠ d·ª• "M·ª©c 1")
        format_created_at(api_item.get("created_at", "")),# Ng√†y t·∫°o converted to UI format
        str(api_item.get("point", "")),                  # ƒêi·ªÉm
        ""                                               # H√†nh ƒë·ªông (b·ªè tr·ªëng ƒë·ªÉ skip)
    ]


def compare_ui_api(ui_data, api_items):
    """
    So s√°nh 2 lists:
    - ui_data: list of lists (each row cells)
    - api_items: list of API items (raw JSON objects)
    Rule:
      - So s√°nh 6 c·ªôt ƒë·∫ßu (b·ªè c·ªôt h√†nh ƒë·ªông)
      - C·ªôt C√¢u h·ªèi (index 2): n·∫øu UI ch·ª©a '...' ·ªü cu·ªëi -> so s√°nh prefix (startsWith),
        n·∫øu kh√¥ng -> strict equality.
      - Ng√†y t·∫°o: API -> convert -> dd/MM/YYYY HH:MM then compare
      - Ch·ªß ƒë·ªÅ: hi·ªán ƒëang so s√°nh b·∫±ng quiz_category_id (ID). N·∫øu UI hi·ªÉn th·ªã t√™n, c·∫ßn mapping
    Tr·∫£ v·ªÅ list of mismatch messages (empty n·∫øu t·∫•t c·∫£ kh·ªõp).
    """
    mismatches = []

    # t·∫°o expected rows list t·ª´ api_items
    expected_rows = [map_api_item_to_ui_row(item) for item in api_items]

    # compare length first
    if len(ui_data) != len(expected_rows):
        mismatches.append(f"S·ªë l∆∞·ª£ng rows kh√°c nhau: UI={len(ui_data)} vs API={len(expected_rows)}")
        # v·∫´n ta ti·∫øp t·ª•c so s√°nh zip ƒë·ªÉ l·∫•y chi ti·∫øt kh√°c (ƒë·ªÉ debug)
    
    total = min(len(ui_data), len(expected_rows))
    for i in range(total):
        ui_row = ui_data[i]
        api_row = expected_rows[i]

        # compare first 6 columns only
        for col_idx in range(6):
            ui_val = ui_row[col_idx] if col_idx < len(ui_row) else ""
            api_val = api_row[col_idx] if col_idx < len(api_row) else ""

            # Column-specific handling
            if col_idx == 2:
                # C√¢u h·ªèi (index 2)
                if ui_val.endswith("..."):
                    prefix = ui_val[:-3]
                    if not api_val.startswith(prefix):
                        mismatches.append(
                            f"Row {i+1} C√¢u h·ªèi prefix mismatch: UI='{ui_val}' | API-starts='{api_val[:len(prefix)+20]}...'"
                        )
                else:
                    if ui_val != api_val:
                        mismatches.append(f"Row {i+1} C√¢u h·ªèi kh√°c: UI='{ui_val}' | API='{api_val}'")
            elif col_idx == 4:
                # Ng√†y t·∫°o: api_val ƒë√£ ƒë∆∞·ª£c format trong map_api_item_to_ui_row()
                if ui_val != api_val:
                    mismatches.append(f"Row {i+1} Ng√†y t·∫°o kh√°c: UI='{ui_val}' | API-formatted='{api_val}'")
            else:
                # strict compare for other columns (id, category, level, point)
                if ui_val != api_val:
                    col_names = ["M√£", "Ch·ªß ƒë·ªÅ", "C√¢u h·ªèi", "ƒê·ªô kh√≥", "Ng√†y t·∫°o", "ƒêi·ªÉm"]
                    mismatches.append(f"Row {i+1} {col_names[col_idx]} kh√°c: UI='{ui_val}' | API='{api_val}'")

    return mismatches


# --------------------------
# Actual pytest test that ties everything together
# --------------------------
@pytest.mark.usefixtures("driver")
def test_compare_question_bank_ui_vs_api(driver):
    """
    Test flow:
    1. login
    2. navigate to question bank
    3. wait & collect performance logs
    4. parse API quizzes response
    5. collect UI table rows
    6. compare via compare_ui_api()
    """
    login_page = LoginPage(driver)
    login_page.login("daotc@el.net", "123456")

    # (optional) small wait to ensure login complete; adjust as needed
    time.sleep(1)

    # v√†o trang Ng√¢n h√†ng c√¢u h·ªèi
    go_to_question_bank(driver)

    # ƒê·ª¢I API g·ªçi -> nh·ªè h∆°n sleep c·ªë ƒë·ªãnh l√† t·ªët nh∆∞ng ·ªü ƒë√¢y d√πng sleep ƒë·ªÉ ƒë∆°n gi·∫£n
    # B·∫°n c√≥ th·ªÉ thay b·∫±ng WebDriverWait ch·ªù spinner bi·∫øn m·∫•t / ho·∫∑c ch·ªù table c√≥ rows
    time.sleep(3)

    # 1) L·∫§Y API t·ª´ performance logs
    api_items = get_api_quizzes_from_performance(driver)
    assert api_items, "‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c API quizzes t·ª´ performance logs"

    # 2) L·∫§Y UI table rows
    ui_rows = get_question_table_ui(driver)
    assert ui_rows, "‚ùå Kh√¥ng t√¨m th·∫•y rows trong UI table"

    # 3) SO S√ÅNH
    mismatches = compare_ui_api(ui_rows, api_items)

    # Print diagnostic info
    if mismatches:
        print("‚ùå C√≥ mismatch sau khi so s√°nh UI <-> API:")
        for m in mismatches:
            print("   -", m)
    else:
        print("‚úÖ UI v√† API kh·ªõp theo rules ƒë√£ ƒë·ªãnh")

    # Final assertion: fail test n·∫øu c√≥ mismatch
    assert not mismatches, "UI v√† API kh√¥ng kh·ªõp (xem log ƒë·ªÉ bi·∫øt chi ti·∫øt)"

